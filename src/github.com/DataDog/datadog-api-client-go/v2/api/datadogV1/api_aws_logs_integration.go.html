<!DOCTYPE html><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="theme-color" content="#375EAB"/>

  <title>src/github.com/DataDog/datadog-api-client-go/v2/api/datadogV1/api_aws_logs_integration.go - Datadog</title>

<link type="text/css" rel="stylesheet" href="https://datadoghq.dev/datadog-api-client-go/lib/godoc/style.css"/>

<script>window.initFuncs = [];</script>
<script src="https://datadoghq.dev/datadog-api-client-go/lib/godoc/jquery.js" defer=""></script>




<script>var goVersion = "go1.19.4";</script>
<script src="https://datadoghq.dev/datadog-api-client-go/lib/godoc/godocs.js" defer=""></script>

</head>
<body>

<div id="lowframe" style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="https:/datadoghq.dev/datadog-api-client-go/pkg/github.com/DataDog/datadog-api-client-go/v2/">Datadog | Datadog API client for GO</a></div>
<div class="top-heading" id="heading-narrow"><a href="https:/datadoghq.dev/datadog-api-client-go/pkg/github.com/DataDog/datadog-api-client-go/v2/">Datadog</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">▽</span></a>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Source file
    <a href="https:/datadoghq.dev/datadog-api-client-go/src">src</a>/<a href="https:/datadoghq.dev/datadog-api-client-go/src/github.com">github.com</a>/<a href="https:/datadoghq.dev/datadog-api-client-go/src/github.com/DataDog">DataDog</a>/<a href="https:/datadoghq.dev/datadog-api-client-go/src/github.com/DataDog/datadog-api-client-go">datadog-api-client-go</a>/<a href="https:/datadoghq.dev/datadog-api-client-go/src/github.com/DataDog/datadog-api-client-go/v2">v2</a>/<a href="https:/datadoghq.dev/datadog-api-client-go/src/github.com/DataDog/datadog-api-client-go/v2/api">api</a>/<a href="https:/datadoghq.dev/datadog-api-client-go/src/github.com/DataDog/datadog-api-client-go/v2/api/datadogV1">datadogV1</a>/<span class="text-muted">api_aws_logs_integration.go</span>
  </h1>





  <h2>
    Documentation: <a href="https:/datadoghq.dev/datadog-api-client-go/pkg/github.com/DataDog/datadog-api-client-go/v2/api/datadogV1">github.com/DataDog/datadog-api-client-go/v2/api/datadogV1</a>
  </h2>



<div id="nav"></div>


<script type="text/javascript">document.ANALYSIS_DATA = null;</script>
<pre><span id="L1" class="ln">     1  </span><span class="comment">// Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.</span>
<span id="L2" class="ln">     2  </span><span class="comment">// This product includes software developed at Datadog (https://www.datadoghq.com/).</span>
<span id="L3" class="ln">     3  </span><span class="comment">// Copyright 2019-Present Datadog, Inc.</span>
<span id="L4" class="ln">     4  </span>
<span id="L5" class="ln">     5  </span>package datadogV1
<span id="L6" class="ln">     6  </span>
<span id="L7" class="ln">     7  </span>import (
<span id="L8" class="ln">     8  </span>	&#34;bytes&#34;
<span id="L9" class="ln">     9  </span>	_context &#34;context&#34;
<span id="L10" class="ln">    10  </span>	_io &#34;io&#34;
<span id="L11" class="ln">    11  </span>	_nethttp &#34;net/http&#34;
<span id="L12" class="ln">    12  </span>	_neturl &#34;net/url&#34;
<span id="L13" class="ln">    13  </span>
<span id="L14" class="ln">    14  </span>	&#34;github.com/DataDog/datadog-api-client-go/v2/api/datadog&#34;
<span id="L15" class="ln">    15  </span>)
<span id="L16" class="ln">    16  </span>
<span id="L17" class="ln">    17  </span><span class="comment">// AWSLogsIntegrationApi service type</span>
<span id="L18" class="ln">    18  </span>type AWSLogsIntegrationApi datadog.Service
<span id="L19" class="ln">    19  </span>
<span id="L20" class="ln">    20  </span>type apiCheckAWSLogsLambdaAsyncRequest struct {
<span id="L21" class="ln">    21  </span>	ctx  _context.Context
<span id="L22" class="ln">    22  </span>	body *AWSAccountAndLambdaRequest
<span id="L23" class="ln">    23  </span>}
<span id="L24" class="ln">    24  </span>
<span id="L25" class="ln">    25  </span>func (a *AWSLogsIntegrationApi) buildCheckAWSLogsLambdaAsyncRequest(ctx _context.Context, body AWSAccountAndLambdaRequest) (apiCheckAWSLogsLambdaAsyncRequest, error) {
<span id="L26" class="ln">    26  </span>	req := apiCheckAWSLogsLambdaAsyncRequest{
<span id="L27" class="ln">    27  </span>		ctx:  ctx,
<span id="L28" class="ln">    28  </span>		body: &amp;body,
<span id="L29" class="ln">    29  </span>	}
<span id="L30" class="ln">    30  </span>	return req, nil
<span id="L31" class="ln">    31  </span>}
<span id="L32" class="ln">    32  </span>
<span id="L33" class="ln">    33  </span><span class="comment">// CheckAWSLogsLambdaAsync Check that an AWS Lambda Function exists.</span>
<span id="L34" class="ln">    34  </span><span class="comment">// Test if permissions are present to add a log-forwarding triggers for the given services and AWS account. The input</span>
<span id="L35" class="ln">    35  </span><span class="comment">// is the same as for Enable an AWS service log collection. Subsequent requests will always repeat the above, so this</span>
<span id="L36" class="ln">    36  </span><span class="comment">// endpoint can be polled intermittently instead of blocking.</span>
<span id="L37" class="ln">    37  </span><span class="comment">//</span>
<span id="L38" class="ln">    38  </span><span class="comment">// - Returns a status of &#39;created&#39; when it&#39;s checking if the Lambda exists in the account.</span>
<span id="L39" class="ln">    39  </span><span class="comment">// - Returns a status of &#39;waiting&#39; while checking.</span>
<span id="L40" class="ln">    40  </span><span class="comment">// - Returns a status of &#39;checked and ok&#39; if the Lambda exists.</span>
<span id="L41" class="ln">    41  </span><span class="comment">// - Returns a status of &#39;error&#39; if the Lambda does not exist.</span>
<span id="L42" class="ln">    42  </span>func (a *AWSLogsIntegrationApi) CheckAWSLogsLambdaAsync(ctx _context.Context, body AWSAccountAndLambdaRequest) (AWSLogsAsyncResponse, *_nethttp.Response, error) {
<span id="L43" class="ln">    43  </span>	req, err := a.buildCheckAWSLogsLambdaAsyncRequest(ctx, body)
<span id="L44" class="ln">    44  </span>	if err != nil {
<span id="L45" class="ln">    45  </span>		var localVarReturnValue AWSLogsAsyncResponse
<span id="L46" class="ln">    46  </span>		return localVarReturnValue, nil, err
<span id="L47" class="ln">    47  </span>	}
<span id="L48" class="ln">    48  </span>
<span id="L49" class="ln">    49  </span>	return a.checkAWSLogsLambdaAsyncExecute(req)
<span id="L50" class="ln">    50  </span>}
<span id="L51" class="ln">    51  </span>
<span id="L52" class="ln">    52  </span><span class="comment">// checkAWSLogsLambdaAsyncExecute executes the request.</span>
<span id="L53" class="ln">    53  </span>func (a *AWSLogsIntegrationApi) checkAWSLogsLambdaAsyncExecute(r apiCheckAWSLogsLambdaAsyncRequest) (AWSLogsAsyncResponse, *_nethttp.Response, error) {
<span id="L54" class="ln">    54  </span>	var (
<span id="L55" class="ln">    55  </span>		localVarHTTPMethod  = _nethttp.MethodPost
<span id="L56" class="ln">    56  </span>		localVarPostBody    interface{}
<span id="L57" class="ln">    57  </span>		localVarReturnValue AWSLogsAsyncResponse
<span id="L58" class="ln">    58  </span>	)
<span id="L59" class="ln">    59  </span>
<span id="L60" class="ln">    60  </span>	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, &#34;v1.AWSLogsIntegrationApi.CheckAWSLogsLambdaAsync&#34;)
<span id="L61" class="ln">    61  </span>	if err != nil {
<span id="L62" class="ln">    62  </span>		return localVarReturnValue, nil, datadog.GenericOpenAPIError{ErrorMessage: err.Error()}
<span id="L63" class="ln">    63  </span>	}
<span id="L64" class="ln">    64  </span>
<span id="L65" class="ln">    65  </span>	localVarPath := localBasePath + &#34;/api/v1/integration/aws/logs/check_async&#34;
<span id="L66" class="ln">    66  </span>
<span id="L67" class="ln">    67  </span>	localVarHeaderParams := make(map[string]string)
<span id="L68" class="ln">    68  </span>	localVarQueryParams := _neturl.Values{}
<span id="L69" class="ln">    69  </span>	localVarFormParams := _neturl.Values{}
<span id="L70" class="ln">    70  </span>	if r.body == nil {
<span id="L71" class="ln">    71  </span>		return localVarReturnValue, nil, datadog.ReportError(&#34;body is required and must be specified&#34;)
<span id="L72" class="ln">    72  </span>	}
<span id="L73" class="ln">    73  </span>	localVarHeaderParams[&#34;Content-Type&#34;] = &#34;application/json&#34;
<span id="L74" class="ln">    74  </span>	localVarHeaderParams[&#34;Accept&#34;] = &#34;application/json&#34;
<span id="L75" class="ln">    75  </span>
<span id="L76" class="ln">    76  </span>	<span class="comment">// body params</span>
<span id="L77" class="ln">    77  </span>	localVarPostBody = r.body
<span id="L78" class="ln">    78  </span>	if r.ctx != nil {
<span id="L79" class="ln">    79  </span>		<span class="comment">// API Key Authentication</span>
<span id="L80" class="ln">    80  </span>		if auth, ok := r.ctx.Value(datadog.ContextAPIKeys).(map[string]datadog.APIKey); ok {
<span id="L81" class="ln">    81  </span>			if apiKey, ok := auth[&#34;apiKeyAuth&#34;]; ok {
<span id="L82" class="ln">    82  </span>				var key string
<span id="L83" class="ln">    83  </span>				if apiKey.Prefix != &#34;&#34; {
<span id="L84" class="ln">    84  </span>					key = apiKey.Prefix + &#34; &#34; + apiKey.Key
<span id="L85" class="ln">    85  </span>				} else {
<span id="L86" class="ln">    86  </span>					key = apiKey.Key
<span id="L87" class="ln">    87  </span>				}
<span id="L88" class="ln">    88  </span>				localVarHeaderParams[&#34;DD-API-KEY&#34;] = key
<span id="L89" class="ln">    89  </span>			}
<span id="L90" class="ln">    90  </span>		}
<span id="L91" class="ln">    91  </span>	}
<span id="L92" class="ln">    92  </span>	if r.ctx != nil {
<span id="L93" class="ln">    93  </span>		<span class="comment">// API Key Authentication</span>
<span id="L94" class="ln">    94  </span>		if auth, ok := r.ctx.Value(datadog.ContextAPIKeys).(map[string]datadog.APIKey); ok {
<span id="L95" class="ln">    95  </span>			if apiKey, ok := auth[&#34;appKeyAuth&#34;]; ok {
<span id="L96" class="ln">    96  </span>				var key string
<span id="L97" class="ln">    97  </span>				if apiKey.Prefix != &#34;&#34; {
<span id="L98" class="ln">    98  </span>					key = apiKey.Prefix + &#34; &#34; + apiKey.Key
<span id="L99" class="ln">    99  </span>				} else {
<span id="L100" class="ln">   100  </span>					key = apiKey.Key
<span id="L101" class="ln">   101  </span>				}
<span id="L102" class="ln">   102  </span>				localVarHeaderParams[&#34;DD-APPLICATION-KEY&#34;] = key
<span id="L103" class="ln">   103  </span>			}
<span id="L104" class="ln">   104  </span>		}
<span id="L105" class="ln">   105  </span>	}
<span id="L106" class="ln">   106  </span>	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, nil)
<span id="L107" class="ln">   107  </span>	if err != nil {
<span id="L108" class="ln">   108  </span>		return localVarReturnValue, nil, err
<span id="L109" class="ln">   109  </span>	}
<span id="L110" class="ln">   110  </span>
<span id="L111" class="ln">   111  </span>	localVarHTTPResponse, err := a.Client.CallAPI(req)
<span id="L112" class="ln">   112  </span>	if err != nil || localVarHTTPResponse == nil {
<span id="L113" class="ln">   113  </span>		return localVarReturnValue, localVarHTTPResponse, err
<span id="L114" class="ln">   114  </span>	}
<span id="L115" class="ln">   115  </span>
<span id="L116" class="ln">   116  </span>	localVarBody, err := _io.ReadAll(localVarHTTPResponse.Body)
<span id="L117" class="ln">   117  </span>	localVarHTTPResponse.Body.Close()
<span id="L118" class="ln">   118  </span>	localVarHTTPResponse.Body = _io.NopCloser(bytes.NewBuffer(localVarBody))
<span id="L119" class="ln">   119  </span>	if err != nil {
<span id="L120" class="ln">   120  </span>		return localVarReturnValue, localVarHTTPResponse, err
<span id="L121" class="ln">   121  </span>	}
<span id="L122" class="ln">   122  </span>
<span id="L123" class="ln">   123  </span>	if localVarHTTPResponse.StatusCode &gt;= 300 {
<span id="L124" class="ln">   124  </span>		newErr := datadog.GenericOpenAPIError{
<span id="L125" class="ln">   125  </span>			ErrorBody:    localVarBody,
<span id="L126" class="ln">   126  </span>			ErrorMessage: localVarHTTPResponse.Status,
<span id="L127" class="ln">   127  </span>		}
<span id="L128" class="ln">   128  </span>		if localVarHTTPResponse.StatusCode == 400 || localVarHTTPResponse.StatusCode == 403 || localVarHTTPResponse.StatusCode == 429 {
<span id="L129" class="ln">   129  </span>			var v APIErrorResponse
<span id="L130" class="ln">   130  </span>			err = a.Client.Decode(&amp;v, localVarBody, localVarHTTPResponse.Header.Get(&#34;Content-Type&#34;))
<span id="L131" class="ln">   131  </span>			if err != nil {
<span id="L132" class="ln">   132  </span>				return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L133" class="ln">   133  </span>			}
<span id="L134" class="ln">   134  </span>			newErr.ErrorModel = v
<span id="L135" class="ln">   135  </span>		}
<span id="L136" class="ln">   136  </span>		return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L137" class="ln">   137  </span>	}
<span id="L138" class="ln">   138  </span>
<span id="L139" class="ln">   139  </span>	err = a.Client.Decode(&amp;localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get(&#34;Content-Type&#34;))
<span id="L140" class="ln">   140  </span>	if err != nil {
<span id="L141" class="ln">   141  </span>		newErr := datadog.GenericOpenAPIError{
<span id="L142" class="ln">   142  </span>			ErrorBody:    localVarBody,
<span id="L143" class="ln">   143  </span>			ErrorMessage: err.Error(),
<span id="L144" class="ln">   144  </span>		}
<span id="L145" class="ln">   145  </span>		return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L146" class="ln">   146  </span>	}
<span id="L147" class="ln">   147  </span>
<span id="L148" class="ln">   148  </span>	return localVarReturnValue, localVarHTTPResponse, nil
<span id="L149" class="ln">   149  </span>}
<span id="L150" class="ln">   150  </span>
<span id="L151" class="ln">   151  </span>type apiCheckAWSLogsServicesAsyncRequest struct {
<span id="L152" class="ln">   152  </span>	ctx  _context.Context
<span id="L153" class="ln">   153  </span>	body *AWSLogsServicesRequest
<span id="L154" class="ln">   154  </span>}
<span id="L155" class="ln">   155  </span>
<span id="L156" class="ln">   156  </span>func (a *AWSLogsIntegrationApi) buildCheckAWSLogsServicesAsyncRequest(ctx _context.Context, body AWSLogsServicesRequest) (apiCheckAWSLogsServicesAsyncRequest, error) {
<span id="L157" class="ln">   157  </span>	req := apiCheckAWSLogsServicesAsyncRequest{
<span id="L158" class="ln">   158  </span>		ctx:  ctx,
<span id="L159" class="ln">   159  </span>		body: &amp;body,
<span id="L160" class="ln">   160  </span>	}
<span id="L161" class="ln">   161  </span>	return req, nil
<span id="L162" class="ln">   162  </span>}
<span id="L163" class="ln">   163  </span>
<span id="L164" class="ln">   164  </span><span class="comment">// CheckAWSLogsServicesAsync Check permissions for log services.</span>
<span id="L165" class="ln">   165  </span><span class="comment">// Test if permissions are present to add log-forwarding triggers for the</span>
<span id="L166" class="ln">   166  </span><span class="comment">// given services and AWS account. Input is the same as for `EnableAWSLogServices`.</span>
<span id="L167" class="ln">   167  </span><span class="comment">// Done async, so can be repeatedly polled in a non-blocking fashion until</span>
<span id="L168" class="ln">   168  </span><span class="comment">// the async request completes.</span>
<span id="L169" class="ln">   169  </span><span class="comment">//</span>
<span id="L170" class="ln">   170  </span><span class="comment">// - Returns a status of `created` when it&#39;s checking if the permissions exists</span>
<span id="L171" class="ln">   171  </span><span class="comment">//   in the AWS account.</span>
<span id="L172" class="ln">   172  </span><span class="comment">// - Returns a status of `waiting` while checking.</span>
<span id="L173" class="ln">   173  </span><span class="comment">// - Returns a status of `checked and ok` if the Lambda exists.</span>
<span id="L174" class="ln">   174  </span><span class="comment">// - Returns a status of `error` if the Lambda does not exist.</span>
<span id="L175" class="ln">   175  </span>func (a *AWSLogsIntegrationApi) CheckAWSLogsServicesAsync(ctx _context.Context, body AWSLogsServicesRequest) (AWSLogsAsyncResponse, *_nethttp.Response, error) {
<span id="L176" class="ln">   176  </span>	req, err := a.buildCheckAWSLogsServicesAsyncRequest(ctx, body)
<span id="L177" class="ln">   177  </span>	if err != nil {
<span id="L178" class="ln">   178  </span>		var localVarReturnValue AWSLogsAsyncResponse
<span id="L179" class="ln">   179  </span>		return localVarReturnValue, nil, err
<span id="L180" class="ln">   180  </span>	}
<span id="L181" class="ln">   181  </span>
<span id="L182" class="ln">   182  </span>	return a.checkAWSLogsServicesAsyncExecute(req)
<span id="L183" class="ln">   183  </span>}
<span id="L184" class="ln">   184  </span>
<span id="L185" class="ln">   185  </span><span class="comment">// checkAWSLogsServicesAsyncExecute executes the request.</span>
<span id="L186" class="ln">   186  </span>func (a *AWSLogsIntegrationApi) checkAWSLogsServicesAsyncExecute(r apiCheckAWSLogsServicesAsyncRequest) (AWSLogsAsyncResponse, *_nethttp.Response, error) {
<span id="L187" class="ln">   187  </span>	var (
<span id="L188" class="ln">   188  </span>		localVarHTTPMethod  = _nethttp.MethodPost
<span id="L189" class="ln">   189  </span>		localVarPostBody    interface{}
<span id="L190" class="ln">   190  </span>		localVarReturnValue AWSLogsAsyncResponse
<span id="L191" class="ln">   191  </span>	)
<span id="L192" class="ln">   192  </span>
<span id="L193" class="ln">   193  </span>	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, &#34;v1.AWSLogsIntegrationApi.CheckAWSLogsServicesAsync&#34;)
<span id="L194" class="ln">   194  </span>	if err != nil {
<span id="L195" class="ln">   195  </span>		return localVarReturnValue, nil, datadog.GenericOpenAPIError{ErrorMessage: err.Error()}
<span id="L196" class="ln">   196  </span>	}
<span id="L197" class="ln">   197  </span>
<span id="L198" class="ln">   198  </span>	localVarPath := localBasePath + &#34;/api/v1/integration/aws/logs/services_async&#34;
<span id="L199" class="ln">   199  </span>
<span id="L200" class="ln">   200  </span>	localVarHeaderParams := make(map[string]string)
<span id="L201" class="ln">   201  </span>	localVarQueryParams := _neturl.Values{}
<span id="L202" class="ln">   202  </span>	localVarFormParams := _neturl.Values{}
<span id="L203" class="ln">   203  </span>	if r.body == nil {
<span id="L204" class="ln">   204  </span>		return localVarReturnValue, nil, datadog.ReportError(&#34;body is required and must be specified&#34;)
<span id="L205" class="ln">   205  </span>	}
<span id="L206" class="ln">   206  </span>	localVarHeaderParams[&#34;Content-Type&#34;] = &#34;application/json&#34;
<span id="L207" class="ln">   207  </span>	localVarHeaderParams[&#34;Accept&#34;] = &#34;application/json&#34;
<span id="L208" class="ln">   208  </span>
<span id="L209" class="ln">   209  </span>	<span class="comment">// body params</span>
<span id="L210" class="ln">   210  </span>	localVarPostBody = r.body
<span id="L211" class="ln">   211  </span>	if r.ctx != nil {
<span id="L212" class="ln">   212  </span>		<span class="comment">// API Key Authentication</span>
<span id="L213" class="ln">   213  </span>		if auth, ok := r.ctx.Value(datadog.ContextAPIKeys).(map[string]datadog.APIKey); ok {
<span id="L214" class="ln">   214  </span>			if apiKey, ok := auth[&#34;apiKeyAuth&#34;]; ok {
<span id="L215" class="ln">   215  </span>				var key string
<span id="L216" class="ln">   216  </span>				if apiKey.Prefix != &#34;&#34; {
<span id="L217" class="ln">   217  </span>					key = apiKey.Prefix + &#34; &#34; + apiKey.Key
<span id="L218" class="ln">   218  </span>				} else {
<span id="L219" class="ln">   219  </span>					key = apiKey.Key
<span id="L220" class="ln">   220  </span>				}
<span id="L221" class="ln">   221  </span>				localVarHeaderParams[&#34;DD-API-KEY&#34;] = key
<span id="L222" class="ln">   222  </span>			}
<span id="L223" class="ln">   223  </span>		}
<span id="L224" class="ln">   224  </span>	}
<span id="L225" class="ln">   225  </span>	if r.ctx != nil {
<span id="L226" class="ln">   226  </span>		<span class="comment">// API Key Authentication</span>
<span id="L227" class="ln">   227  </span>		if auth, ok := r.ctx.Value(datadog.ContextAPIKeys).(map[string]datadog.APIKey); ok {
<span id="L228" class="ln">   228  </span>			if apiKey, ok := auth[&#34;appKeyAuth&#34;]; ok {
<span id="L229" class="ln">   229  </span>				var key string
<span id="L230" class="ln">   230  </span>				if apiKey.Prefix != &#34;&#34; {
<span id="L231" class="ln">   231  </span>					key = apiKey.Prefix + &#34; &#34; + apiKey.Key
<span id="L232" class="ln">   232  </span>				} else {
<span id="L233" class="ln">   233  </span>					key = apiKey.Key
<span id="L234" class="ln">   234  </span>				}
<span id="L235" class="ln">   235  </span>				localVarHeaderParams[&#34;DD-APPLICATION-KEY&#34;] = key
<span id="L236" class="ln">   236  </span>			}
<span id="L237" class="ln">   237  </span>		}
<span id="L238" class="ln">   238  </span>	}
<span id="L239" class="ln">   239  </span>	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, nil)
<span id="L240" class="ln">   240  </span>	if err != nil {
<span id="L241" class="ln">   241  </span>		return localVarReturnValue, nil, err
<span id="L242" class="ln">   242  </span>	}
<span id="L243" class="ln">   243  </span>
<span id="L244" class="ln">   244  </span>	localVarHTTPResponse, err := a.Client.CallAPI(req)
<span id="L245" class="ln">   245  </span>	if err != nil || localVarHTTPResponse == nil {
<span id="L246" class="ln">   246  </span>		return localVarReturnValue, localVarHTTPResponse, err
<span id="L247" class="ln">   247  </span>	}
<span id="L248" class="ln">   248  </span>
<span id="L249" class="ln">   249  </span>	localVarBody, err := _io.ReadAll(localVarHTTPResponse.Body)
<span id="L250" class="ln">   250  </span>	localVarHTTPResponse.Body.Close()
<span id="L251" class="ln">   251  </span>	localVarHTTPResponse.Body = _io.NopCloser(bytes.NewBuffer(localVarBody))
<span id="L252" class="ln">   252  </span>	if err != nil {
<span id="L253" class="ln">   253  </span>		return localVarReturnValue, localVarHTTPResponse, err
<span id="L254" class="ln">   254  </span>	}
<span id="L255" class="ln">   255  </span>
<span id="L256" class="ln">   256  </span>	if localVarHTTPResponse.StatusCode &gt;= 300 {
<span id="L257" class="ln">   257  </span>		newErr := datadog.GenericOpenAPIError{
<span id="L258" class="ln">   258  </span>			ErrorBody:    localVarBody,
<span id="L259" class="ln">   259  </span>			ErrorMessage: localVarHTTPResponse.Status,
<span id="L260" class="ln">   260  </span>		}
<span id="L261" class="ln">   261  </span>		if localVarHTTPResponse.StatusCode == 400 || localVarHTTPResponse.StatusCode == 403 || localVarHTTPResponse.StatusCode == 429 {
<span id="L262" class="ln">   262  </span>			var v APIErrorResponse
<span id="L263" class="ln">   263  </span>			err = a.Client.Decode(&amp;v, localVarBody, localVarHTTPResponse.Header.Get(&#34;Content-Type&#34;))
<span id="L264" class="ln">   264  </span>			if err != nil {
<span id="L265" class="ln">   265  </span>				return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L266" class="ln">   266  </span>			}
<span id="L267" class="ln">   267  </span>			newErr.ErrorModel = v
<span id="L268" class="ln">   268  </span>		}
<span id="L269" class="ln">   269  </span>		return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L270" class="ln">   270  </span>	}
<span id="L271" class="ln">   271  </span>
<span id="L272" class="ln">   272  </span>	err = a.Client.Decode(&amp;localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get(&#34;Content-Type&#34;))
<span id="L273" class="ln">   273  </span>	if err != nil {
<span id="L274" class="ln">   274  </span>		newErr := datadog.GenericOpenAPIError{
<span id="L275" class="ln">   275  </span>			ErrorBody:    localVarBody,
<span id="L276" class="ln">   276  </span>			ErrorMessage: err.Error(),
<span id="L277" class="ln">   277  </span>		}
<span id="L278" class="ln">   278  </span>		return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L279" class="ln">   279  </span>	}
<span id="L280" class="ln">   280  </span>
<span id="L281" class="ln">   281  </span>	return localVarReturnValue, localVarHTTPResponse, nil
<span id="L282" class="ln">   282  </span>}
<span id="L283" class="ln">   283  </span>
<span id="L284" class="ln">   284  </span>type apiCreateAWSLambdaARNRequest struct {
<span id="L285" class="ln">   285  </span>	ctx  _context.Context
<span id="L286" class="ln">   286  </span>	body *AWSAccountAndLambdaRequest
<span id="L287" class="ln">   287  </span>}
<span id="L288" class="ln">   288  </span>
<span id="L289" class="ln">   289  </span>func (a *AWSLogsIntegrationApi) buildCreateAWSLambdaARNRequest(ctx _context.Context, body AWSAccountAndLambdaRequest) (apiCreateAWSLambdaARNRequest, error) {
<span id="L290" class="ln">   290  </span>	req := apiCreateAWSLambdaARNRequest{
<span id="L291" class="ln">   291  </span>		ctx:  ctx,
<span id="L292" class="ln">   292  </span>		body: &amp;body,
<span id="L293" class="ln">   293  </span>	}
<span id="L294" class="ln">   294  </span>	return req, nil
<span id="L295" class="ln">   295  </span>}
<span id="L296" class="ln">   296  </span>
<span id="L297" class="ln">   297  </span><span class="comment">// CreateAWSLambdaARN Add AWS Log Lambda ARN.</span>
<span id="L298" class="ln">   298  </span><span class="comment">// Attach the Lambda ARN of the Lambda created for the Datadog-AWS log collection to your AWS account ID to enable log collection.</span>
<span id="L299" class="ln">   299  </span>func (a *AWSLogsIntegrationApi) CreateAWSLambdaARN(ctx _context.Context, body AWSAccountAndLambdaRequest) (interface{}, *_nethttp.Response, error) {
<span id="L300" class="ln">   300  </span>	req, err := a.buildCreateAWSLambdaARNRequest(ctx, body)
<span id="L301" class="ln">   301  </span>	if err != nil {
<span id="L302" class="ln">   302  </span>		var localVarReturnValue interface{}
<span id="L303" class="ln">   303  </span>		return localVarReturnValue, nil, err
<span id="L304" class="ln">   304  </span>	}
<span id="L305" class="ln">   305  </span>
<span id="L306" class="ln">   306  </span>	return a.createAWSLambdaARNExecute(req)
<span id="L307" class="ln">   307  </span>}
<span id="L308" class="ln">   308  </span>
<span id="L309" class="ln">   309  </span><span class="comment">// createAWSLambdaARNExecute executes the request.</span>
<span id="L310" class="ln">   310  </span>func (a *AWSLogsIntegrationApi) createAWSLambdaARNExecute(r apiCreateAWSLambdaARNRequest) (interface{}, *_nethttp.Response, error) {
<span id="L311" class="ln">   311  </span>	var (
<span id="L312" class="ln">   312  </span>		localVarHTTPMethod  = _nethttp.MethodPost
<span id="L313" class="ln">   313  </span>		localVarPostBody    interface{}
<span id="L314" class="ln">   314  </span>		localVarReturnValue interface{}
<span id="L315" class="ln">   315  </span>	)
<span id="L316" class="ln">   316  </span>
<span id="L317" class="ln">   317  </span>	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, &#34;v1.AWSLogsIntegrationApi.CreateAWSLambdaARN&#34;)
<span id="L318" class="ln">   318  </span>	if err != nil {
<span id="L319" class="ln">   319  </span>		return localVarReturnValue, nil, datadog.GenericOpenAPIError{ErrorMessage: err.Error()}
<span id="L320" class="ln">   320  </span>	}
<span id="L321" class="ln">   321  </span>
<span id="L322" class="ln">   322  </span>	localVarPath := localBasePath + &#34;/api/v1/integration/aws/logs&#34;
<span id="L323" class="ln">   323  </span>
<span id="L324" class="ln">   324  </span>	localVarHeaderParams := make(map[string]string)
<span id="L325" class="ln">   325  </span>	localVarQueryParams := _neturl.Values{}
<span id="L326" class="ln">   326  </span>	localVarFormParams := _neturl.Values{}
<span id="L327" class="ln">   327  </span>	if r.body == nil {
<span id="L328" class="ln">   328  </span>		return localVarReturnValue, nil, datadog.ReportError(&#34;body is required and must be specified&#34;)
<span id="L329" class="ln">   329  </span>	}
<span id="L330" class="ln">   330  </span>	localVarHeaderParams[&#34;Content-Type&#34;] = &#34;application/json&#34;
<span id="L331" class="ln">   331  </span>	localVarHeaderParams[&#34;Accept&#34;] = &#34;application/json&#34;
<span id="L332" class="ln">   332  </span>
<span id="L333" class="ln">   333  </span>	<span class="comment">// body params</span>
<span id="L334" class="ln">   334  </span>	localVarPostBody = r.body
<span id="L335" class="ln">   335  </span>	if r.ctx != nil {
<span id="L336" class="ln">   336  </span>		<span class="comment">// API Key Authentication</span>
<span id="L337" class="ln">   337  </span>		if auth, ok := r.ctx.Value(datadog.ContextAPIKeys).(map[string]datadog.APIKey); ok {
<span id="L338" class="ln">   338  </span>			if apiKey, ok := auth[&#34;apiKeyAuth&#34;]; ok {
<span id="L339" class="ln">   339  </span>				var key string
<span id="L340" class="ln">   340  </span>				if apiKey.Prefix != &#34;&#34; {
<span id="L341" class="ln">   341  </span>					key = apiKey.Prefix + &#34; &#34; + apiKey.Key
<span id="L342" class="ln">   342  </span>				} else {
<span id="L343" class="ln">   343  </span>					key = apiKey.Key
<span id="L344" class="ln">   344  </span>				}
<span id="L345" class="ln">   345  </span>				localVarHeaderParams[&#34;DD-API-KEY&#34;] = key
<span id="L346" class="ln">   346  </span>			}
<span id="L347" class="ln">   347  </span>		}
<span id="L348" class="ln">   348  </span>	}
<span id="L349" class="ln">   349  </span>	if r.ctx != nil {
<span id="L350" class="ln">   350  </span>		<span class="comment">// API Key Authentication</span>
<span id="L351" class="ln">   351  </span>		if auth, ok := r.ctx.Value(datadog.ContextAPIKeys).(map[string]datadog.APIKey); ok {
<span id="L352" class="ln">   352  </span>			if apiKey, ok := auth[&#34;appKeyAuth&#34;]; ok {
<span id="L353" class="ln">   353  </span>				var key string
<span id="L354" class="ln">   354  </span>				if apiKey.Prefix != &#34;&#34; {
<span id="L355" class="ln">   355  </span>					key = apiKey.Prefix + &#34; &#34; + apiKey.Key
<span id="L356" class="ln">   356  </span>				} else {
<span id="L357" class="ln">   357  </span>					key = apiKey.Key
<span id="L358" class="ln">   358  </span>				}
<span id="L359" class="ln">   359  </span>				localVarHeaderParams[&#34;DD-APPLICATION-KEY&#34;] = key
<span id="L360" class="ln">   360  </span>			}
<span id="L361" class="ln">   361  </span>		}
<span id="L362" class="ln">   362  </span>	}
<span id="L363" class="ln">   363  </span>	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, nil)
<span id="L364" class="ln">   364  </span>	if err != nil {
<span id="L365" class="ln">   365  </span>		return localVarReturnValue, nil, err
<span id="L366" class="ln">   366  </span>	}
<span id="L367" class="ln">   367  </span>
<span id="L368" class="ln">   368  </span>	localVarHTTPResponse, err := a.Client.CallAPI(req)
<span id="L369" class="ln">   369  </span>	if err != nil || localVarHTTPResponse == nil {
<span id="L370" class="ln">   370  </span>		return localVarReturnValue, localVarHTTPResponse, err
<span id="L371" class="ln">   371  </span>	}
<span id="L372" class="ln">   372  </span>
<span id="L373" class="ln">   373  </span>	localVarBody, err := _io.ReadAll(localVarHTTPResponse.Body)
<span id="L374" class="ln">   374  </span>	localVarHTTPResponse.Body.Close()
<span id="L375" class="ln">   375  </span>	localVarHTTPResponse.Body = _io.NopCloser(bytes.NewBuffer(localVarBody))
<span id="L376" class="ln">   376  </span>	if err != nil {
<span id="L377" class="ln">   377  </span>		return localVarReturnValue, localVarHTTPResponse, err
<span id="L378" class="ln">   378  </span>	}
<span id="L379" class="ln">   379  </span>
<span id="L380" class="ln">   380  </span>	if localVarHTTPResponse.StatusCode &gt;= 300 {
<span id="L381" class="ln">   381  </span>		newErr := datadog.GenericOpenAPIError{
<span id="L382" class="ln">   382  </span>			ErrorBody:    localVarBody,
<span id="L383" class="ln">   383  </span>			ErrorMessage: localVarHTTPResponse.Status,
<span id="L384" class="ln">   384  </span>		}
<span id="L385" class="ln">   385  </span>		if localVarHTTPResponse.StatusCode == 400 || localVarHTTPResponse.StatusCode == 403 || localVarHTTPResponse.StatusCode == 429 {
<span id="L386" class="ln">   386  </span>			var v APIErrorResponse
<span id="L387" class="ln">   387  </span>			err = a.Client.Decode(&amp;v, localVarBody, localVarHTTPResponse.Header.Get(&#34;Content-Type&#34;))
<span id="L388" class="ln">   388  </span>			if err != nil {
<span id="L389" class="ln">   389  </span>				return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L390" class="ln">   390  </span>			}
<span id="L391" class="ln">   391  </span>			newErr.ErrorModel = v
<span id="L392" class="ln">   392  </span>		}
<span id="L393" class="ln">   393  </span>		return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L394" class="ln">   394  </span>	}
<span id="L395" class="ln">   395  </span>
<span id="L396" class="ln">   396  </span>	err = a.Client.Decode(&amp;localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get(&#34;Content-Type&#34;))
<span id="L397" class="ln">   397  </span>	if err != nil {
<span id="L398" class="ln">   398  </span>		newErr := datadog.GenericOpenAPIError{
<span id="L399" class="ln">   399  </span>			ErrorBody:    localVarBody,
<span id="L400" class="ln">   400  </span>			ErrorMessage: err.Error(),
<span id="L401" class="ln">   401  </span>		}
<span id="L402" class="ln">   402  </span>		return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L403" class="ln">   403  </span>	}
<span id="L404" class="ln">   404  </span>
<span id="L405" class="ln">   405  </span>	return localVarReturnValue, localVarHTTPResponse, nil
<span id="L406" class="ln">   406  </span>}
<span id="L407" class="ln">   407  </span>
<span id="L408" class="ln">   408  </span>type apiDeleteAWSLambdaARNRequest struct {
<span id="L409" class="ln">   409  </span>	ctx  _context.Context
<span id="L410" class="ln">   410  </span>	body *AWSAccountAndLambdaRequest
<span id="L411" class="ln">   411  </span>}
<span id="L412" class="ln">   412  </span>
<span id="L413" class="ln">   413  </span>func (a *AWSLogsIntegrationApi) buildDeleteAWSLambdaARNRequest(ctx _context.Context, body AWSAccountAndLambdaRequest) (apiDeleteAWSLambdaARNRequest, error) {
<span id="L414" class="ln">   414  </span>	req := apiDeleteAWSLambdaARNRequest{
<span id="L415" class="ln">   415  </span>		ctx:  ctx,
<span id="L416" class="ln">   416  </span>		body: &amp;body,
<span id="L417" class="ln">   417  </span>	}
<span id="L418" class="ln">   418  </span>	return req, nil
<span id="L419" class="ln">   419  </span>}
<span id="L420" class="ln">   420  </span>
<span id="L421" class="ln">   421  </span><span class="comment">// DeleteAWSLambdaARN Delete an AWS Logs integration.</span>
<span id="L422" class="ln">   422  </span><span class="comment">// Delete a Datadog-AWS logs configuration by removing the specific Lambda ARN associated with a given AWS account.</span>
<span id="L423" class="ln">   423  </span>func (a *AWSLogsIntegrationApi) DeleteAWSLambdaARN(ctx _context.Context, body AWSAccountAndLambdaRequest) (interface{}, *_nethttp.Response, error) {
<span id="L424" class="ln">   424  </span>	req, err := a.buildDeleteAWSLambdaARNRequest(ctx, body)
<span id="L425" class="ln">   425  </span>	if err != nil {
<span id="L426" class="ln">   426  </span>		var localVarReturnValue interface{}
<span id="L427" class="ln">   427  </span>		return localVarReturnValue, nil, err
<span id="L428" class="ln">   428  </span>	}
<span id="L429" class="ln">   429  </span>
<span id="L430" class="ln">   430  </span>	return a.deleteAWSLambdaARNExecute(req)
<span id="L431" class="ln">   431  </span>}
<span id="L432" class="ln">   432  </span>
<span id="L433" class="ln">   433  </span><span class="comment">// deleteAWSLambdaARNExecute executes the request.</span>
<span id="L434" class="ln">   434  </span>func (a *AWSLogsIntegrationApi) deleteAWSLambdaARNExecute(r apiDeleteAWSLambdaARNRequest) (interface{}, *_nethttp.Response, error) {
<span id="L435" class="ln">   435  </span>	var (
<span id="L436" class="ln">   436  </span>		localVarHTTPMethod  = _nethttp.MethodDelete
<span id="L437" class="ln">   437  </span>		localVarPostBody    interface{}
<span id="L438" class="ln">   438  </span>		localVarReturnValue interface{}
<span id="L439" class="ln">   439  </span>	)
<span id="L440" class="ln">   440  </span>
<span id="L441" class="ln">   441  </span>	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, &#34;v1.AWSLogsIntegrationApi.DeleteAWSLambdaARN&#34;)
<span id="L442" class="ln">   442  </span>	if err != nil {
<span id="L443" class="ln">   443  </span>		return localVarReturnValue, nil, datadog.GenericOpenAPIError{ErrorMessage: err.Error()}
<span id="L444" class="ln">   444  </span>	}
<span id="L445" class="ln">   445  </span>
<span id="L446" class="ln">   446  </span>	localVarPath := localBasePath + &#34;/api/v1/integration/aws/logs&#34;
<span id="L447" class="ln">   447  </span>
<span id="L448" class="ln">   448  </span>	localVarHeaderParams := make(map[string]string)
<span id="L449" class="ln">   449  </span>	localVarQueryParams := _neturl.Values{}
<span id="L450" class="ln">   450  </span>	localVarFormParams := _neturl.Values{}
<span id="L451" class="ln">   451  </span>	if r.body == nil {
<span id="L452" class="ln">   452  </span>		return localVarReturnValue, nil, datadog.ReportError(&#34;body is required and must be specified&#34;)
<span id="L453" class="ln">   453  </span>	}
<span id="L454" class="ln">   454  </span>	localVarHeaderParams[&#34;Content-Type&#34;] = &#34;application/json&#34;
<span id="L455" class="ln">   455  </span>	localVarHeaderParams[&#34;Accept&#34;] = &#34;application/json&#34;
<span id="L456" class="ln">   456  </span>
<span id="L457" class="ln">   457  </span>	<span class="comment">// body params</span>
<span id="L458" class="ln">   458  </span>	localVarPostBody = r.body
<span id="L459" class="ln">   459  </span>	if r.ctx != nil {
<span id="L460" class="ln">   460  </span>		<span class="comment">// API Key Authentication</span>
<span id="L461" class="ln">   461  </span>		if auth, ok := r.ctx.Value(datadog.ContextAPIKeys).(map[string]datadog.APIKey); ok {
<span id="L462" class="ln">   462  </span>			if apiKey, ok := auth[&#34;apiKeyAuth&#34;]; ok {
<span id="L463" class="ln">   463  </span>				var key string
<span id="L464" class="ln">   464  </span>				if apiKey.Prefix != &#34;&#34; {
<span id="L465" class="ln">   465  </span>					key = apiKey.Prefix + &#34; &#34; + apiKey.Key
<span id="L466" class="ln">   466  </span>				} else {
<span id="L467" class="ln">   467  </span>					key = apiKey.Key
<span id="L468" class="ln">   468  </span>				}
<span id="L469" class="ln">   469  </span>				localVarHeaderParams[&#34;DD-API-KEY&#34;] = key
<span id="L470" class="ln">   470  </span>			}
<span id="L471" class="ln">   471  </span>		}
<span id="L472" class="ln">   472  </span>	}
<span id="L473" class="ln">   473  </span>	if r.ctx != nil {
<span id="L474" class="ln">   474  </span>		<span class="comment">// API Key Authentication</span>
<span id="L475" class="ln">   475  </span>		if auth, ok := r.ctx.Value(datadog.ContextAPIKeys).(map[string]datadog.APIKey); ok {
<span id="L476" class="ln">   476  </span>			if apiKey, ok := auth[&#34;appKeyAuth&#34;]; ok {
<span id="L477" class="ln">   477  </span>				var key string
<span id="L478" class="ln">   478  </span>				if apiKey.Prefix != &#34;&#34; {
<span id="L479" class="ln">   479  </span>					key = apiKey.Prefix + &#34; &#34; + apiKey.Key
<span id="L480" class="ln">   480  </span>				} else {
<span id="L481" class="ln">   481  </span>					key = apiKey.Key
<span id="L482" class="ln">   482  </span>				}
<span id="L483" class="ln">   483  </span>				localVarHeaderParams[&#34;DD-APPLICATION-KEY&#34;] = key
<span id="L484" class="ln">   484  </span>			}
<span id="L485" class="ln">   485  </span>		}
<span id="L486" class="ln">   486  </span>	}
<span id="L487" class="ln">   487  </span>	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, nil)
<span id="L488" class="ln">   488  </span>	if err != nil {
<span id="L489" class="ln">   489  </span>		return localVarReturnValue, nil, err
<span id="L490" class="ln">   490  </span>	}
<span id="L491" class="ln">   491  </span>
<span id="L492" class="ln">   492  </span>	localVarHTTPResponse, err := a.Client.CallAPI(req)
<span id="L493" class="ln">   493  </span>	if err != nil || localVarHTTPResponse == nil {
<span id="L494" class="ln">   494  </span>		return localVarReturnValue, localVarHTTPResponse, err
<span id="L495" class="ln">   495  </span>	}
<span id="L496" class="ln">   496  </span>
<span id="L497" class="ln">   497  </span>	localVarBody, err := _io.ReadAll(localVarHTTPResponse.Body)
<span id="L498" class="ln">   498  </span>	localVarHTTPResponse.Body.Close()
<span id="L499" class="ln">   499  </span>	localVarHTTPResponse.Body = _io.NopCloser(bytes.NewBuffer(localVarBody))
<span id="L500" class="ln">   500  </span>	if err != nil {
<span id="L501" class="ln">   501  </span>		return localVarReturnValue, localVarHTTPResponse, err
<span id="L502" class="ln">   502  </span>	}
<span id="L503" class="ln">   503  </span>
<span id="L504" class="ln">   504  </span>	if localVarHTTPResponse.StatusCode &gt;= 300 {
<span id="L505" class="ln">   505  </span>		newErr := datadog.GenericOpenAPIError{
<span id="L506" class="ln">   506  </span>			ErrorBody:    localVarBody,
<span id="L507" class="ln">   507  </span>			ErrorMessage: localVarHTTPResponse.Status,
<span id="L508" class="ln">   508  </span>		}
<span id="L509" class="ln">   509  </span>		if localVarHTTPResponse.StatusCode == 400 || localVarHTTPResponse.StatusCode == 403 || localVarHTTPResponse.StatusCode == 429 {
<span id="L510" class="ln">   510  </span>			var v APIErrorResponse
<span id="L511" class="ln">   511  </span>			err = a.Client.Decode(&amp;v, localVarBody, localVarHTTPResponse.Header.Get(&#34;Content-Type&#34;))
<span id="L512" class="ln">   512  </span>			if err != nil {
<span id="L513" class="ln">   513  </span>				return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L514" class="ln">   514  </span>			}
<span id="L515" class="ln">   515  </span>			newErr.ErrorModel = v
<span id="L516" class="ln">   516  </span>		}
<span id="L517" class="ln">   517  </span>		return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L518" class="ln">   518  </span>	}
<span id="L519" class="ln">   519  </span>
<span id="L520" class="ln">   520  </span>	err = a.Client.Decode(&amp;localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get(&#34;Content-Type&#34;))
<span id="L521" class="ln">   521  </span>	if err != nil {
<span id="L522" class="ln">   522  </span>		newErr := datadog.GenericOpenAPIError{
<span id="L523" class="ln">   523  </span>			ErrorBody:    localVarBody,
<span id="L524" class="ln">   524  </span>			ErrorMessage: err.Error(),
<span id="L525" class="ln">   525  </span>		}
<span id="L526" class="ln">   526  </span>		return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L527" class="ln">   527  </span>	}
<span id="L528" class="ln">   528  </span>
<span id="L529" class="ln">   529  </span>	return localVarReturnValue, localVarHTTPResponse, nil
<span id="L530" class="ln">   530  </span>}
<span id="L531" class="ln">   531  </span>
<span id="L532" class="ln">   532  </span>type apiEnableAWSLogServicesRequest struct {
<span id="L533" class="ln">   533  </span>	ctx  _context.Context
<span id="L534" class="ln">   534  </span>	body *AWSLogsServicesRequest
<span id="L535" class="ln">   535  </span>}
<span id="L536" class="ln">   536  </span>
<span id="L537" class="ln">   537  </span>func (a *AWSLogsIntegrationApi) buildEnableAWSLogServicesRequest(ctx _context.Context, body AWSLogsServicesRequest) (apiEnableAWSLogServicesRequest, error) {
<span id="L538" class="ln">   538  </span>	req := apiEnableAWSLogServicesRequest{
<span id="L539" class="ln">   539  </span>		ctx:  ctx,
<span id="L540" class="ln">   540  </span>		body: &amp;body,
<span id="L541" class="ln">   541  </span>	}
<span id="L542" class="ln">   542  </span>	return req, nil
<span id="L543" class="ln">   543  </span>}
<span id="L544" class="ln">   544  </span>
<span id="L545" class="ln">   545  </span><span class="comment">// EnableAWSLogServices Enable an AWS Logs integration.</span>
<span id="L546" class="ln">   546  </span><span class="comment">// Enable automatic log collection for a list of services. This should be run after running `CreateAWSLambdaARN` to save the configuration.</span>
<span id="L547" class="ln">   547  </span>func (a *AWSLogsIntegrationApi) EnableAWSLogServices(ctx _context.Context, body AWSLogsServicesRequest) (interface{}, *_nethttp.Response, error) {
<span id="L548" class="ln">   548  </span>	req, err := a.buildEnableAWSLogServicesRequest(ctx, body)
<span id="L549" class="ln">   549  </span>	if err != nil {
<span id="L550" class="ln">   550  </span>		var localVarReturnValue interface{}
<span id="L551" class="ln">   551  </span>		return localVarReturnValue, nil, err
<span id="L552" class="ln">   552  </span>	}
<span id="L553" class="ln">   553  </span>
<span id="L554" class="ln">   554  </span>	return a.enableAWSLogServicesExecute(req)
<span id="L555" class="ln">   555  </span>}
<span id="L556" class="ln">   556  </span>
<span id="L557" class="ln">   557  </span><span class="comment">// enableAWSLogServicesExecute executes the request.</span>
<span id="L558" class="ln">   558  </span>func (a *AWSLogsIntegrationApi) enableAWSLogServicesExecute(r apiEnableAWSLogServicesRequest) (interface{}, *_nethttp.Response, error) {
<span id="L559" class="ln">   559  </span>	var (
<span id="L560" class="ln">   560  </span>		localVarHTTPMethod  = _nethttp.MethodPost
<span id="L561" class="ln">   561  </span>		localVarPostBody    interface{}
<span id="L562" class="ln">   562  </span>		localVarReturnValue interface{}
<span id="L563" class="ln">   563  </span>	)
<span id="L564" class="ln">   564  </span>
<span id="L565" class="ln">   565  </span>	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, &#34;v1.AWSLogsIntegrationApi.EnableAWSLogServices&#34;)
<span id="L566" class="ln">   566  </span>	if err != nil {
<span id="L567" class="ln">   567  </span>		return localVarReturnValue, nil, datadog.GenericOpenAPIError{ErrorMessage: err.Error()}
<span id="L568" class="ln">   568  </span>	}
<span id="L569" class="ln">   569  </span>
<span id="L570" class="ln">   570  </span>	localVarPath := localBasePath + &#34;/api/v1/integration/aws/logs/services&#34;
<span id="L571" class="ln">   571  </span>
<span id="L572" class="ln">   572  </span>	localVarHeaderParams := make(map[string]string)
<span id="L573" class="ln">   573  </span>	localVarQueryParams := _neturl.Values{}
<span id="L574" class="ln">   574  </span>	localVarFormParams := _neturl.Values{}
<span id="L575" class="ln">   575  </span>	if r.body == nil {
<span id="L576" class="ln">   576  </span>		return localVarReturnValue, nil, datadog.ReportError(&#34;body is required and must be specified&#34;)
<span id="L577" class="ln">   577  </span>	}
<span id="L578" class="ln">   578  </span>	localVarHeaderParams[&#34;Content-Type&#34;] = &#34;application/json&#34;
<span id="L579" class="ln">   579  </span>	localVarHeaderParams[&#34;Accept&#34;] = &#34;application/json&#34;
<span id="L580" class="ln">   580  </span>
<span id="L581" class="ln">   581  </span>	<span class="comment">// body params</span>
<span id="L582" class="ln">   582  </span>	localVarPostBody = r.body
<span id="L583" class="ln">   583  </span>	if r.ctx != nil {
<span id="L584" class="ln">   584  </span>		<span class="comment">// API Key Authentication</span>
<span id="L585" class="ln">   585  </span>		if auth, ok := r.ctx.Value(datadog.ContextAPIKeys).(map[string]datadog.APIKey); ok {
<span id="L586" class="ln">   586  </span>			if apiKey, ok := auth[&#34;apiKeyAuth&#34;]; ok {
<span id="L587" class="ln">   587  </span>				var key string
<span id="L588" class="ln">   588  </span>				if apiKey.Prefix != &#34;&#34; {
<span id="L589" class="ln">   589  </span>					key = apiKey.Prefix + &#34; &#34; + apiKey.Key
<span id="L590" class="ln">   590  </span>				} else {
<span id="L591" class="ln">   591  </span>					key = apiKey.Key
<span id="L592" class="ln">   592  </span>				}
<span id="L593" class="ln">   593  </span>				localVarHeaderParams[&#34;DD-API-KEY&#34;] = key
<span id="L594" class="ln">   594  </span>			}
<span id="L595" class="ln">   595  </span>		}
<span id="L596" class="ln">   596  </span>	}
<span id="L597" class="ln">   597  </span>	if r.ctx != nil {
<span id="L598" class="ln">   598  </span>		<span class="comment">// API Key Authentication</span>
<span id="L599" class="ln">   599  </span>		if auth, ok := r.ctx.Value(datadog.ContextAPIKeys).(map[string]datadog.APIKey); ok {
<span id="L600" class="ln">   600  </span>			if apiKey, ok := auth[&#34;appKeyAuth&#34;]; ok {
<span id="L601" class="ln">   601  </span>				var key string
<span id="L602" class="ln">   602  </span>				if apiKey.Prefix != &#34;&#34; {
<span id="L603" class="ln">   603  </span>					key = apiKey.Prefix + &#34; &#34; + apiKey.Key
<span id="L604" class="ln">   604  </span>				} else {
<span id="L605" class="ln">   605  </span>					key = apiKey.Key
<span id="L606" class="ln">   606  </span>				}
<span id="L607" class="ln">   607  </span>				localVarHeaderParams[&#34;DD-APPLICATION-KEY&#34;] = key
<span id="L608" class="ln">   608  </span>			}
<span id="L609" class="ln">   609  </span>		}
<span id="L610" class="ln">   610  </span>	}
<span id="L611" class="ln">   611  </span>	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, nil)
<span id="L612" class="ln">   612  </span>	if err != nil {
<span id="L613" class="ln">   613  </span>		return localVarReturnValue, nil, err
<span id="L614" class="ln">   614  </span>	}
<span id="L615" class="ln">   615  </span>
<span id="L616" class="ln">   616  </span>	localVarHTTPResponse, err := a.Client.CallAPI(req)
<span id="L617" class="ln">   617  </span>	if err != nil || localVarHTTPResponse == nil {
<span id="L618" class="ln">   618  </span>		return localVarReturnValue, localVarHTTPResponse, err
<span id="L619" class="ln">   619  </span>	}
<span id="L620" class="ln">   620  </span>
<span id="L621" class="ln">   621  </span>	localVarBody, err := _io.ReadAll(localVarHTTPResponse.Body)
<span id="L622" class="ln">   622  </span>	localVarHTTPResponse.Body.Close()
<span id="L623" class="ln">   623  </span>	localVarHTTPResponse.Body = _io.NopCloser(bytes.NewBuffer(localVarBody))
<span id="L624" class="ln">   624  </span>	if err != nil {
<span id="L625" class="ln">   625  </span>		return localVarReturnValue, localVarHTTPResponse, err
<span id="L626" class="ln">   626  </span>	}
<span id="L627" class="ln">   627  </span>
<span id="L628" class="ln">   628  </span>	if localVarHTTPResponse.StatusCode &gt;= 300 {
<span id="L629" class="ln">   629  </span>		newErr := datadog.GenericOpenAPIError{
<span id="L630" class="ln">   630  </span>			ErrorBody:    localVarBody,
<span id="L631" class="ln">   631  </span>			ErrorMessage: localVarHTTPResponse.Status,
<span id="L632" class="ln">   632  </span>		}
<span id="L633" class="ln">   633  </span>		if localVarHTTPResponse.StatusCode == 400 || localVarHTTPResponse.StatusCode == 403 || localVarHTTPResponse.StatusCode == 429 {
<span id="L634" class="ln">   634  </span>			var v APIErrorResponse
<span id="L635" class="ln">   635  </span>			err = a.Client.Decode(&amp;v, localVarBody, localVarHTTPResponse.Header.Get(&#34;Content-Type&#34;))
<span id="L636" class="ln">   636  </span>			if err != nil {
<span id="L637" class="ln">   637  </span>				return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L638" class="ln">   638  </span>			}
<span id="L639" class="ln">   639  </span>			newErr.ErrorModel = v
<span id="L640" class="ln">   640  </span>		}
<span id="L641" class="ln">   641  </span>		return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L642" class="ln">   642  </span>	}
<span id="L643" class="ln">   643  </span>
<span id="L644" class="ln">   644  </span>	err = a.Client.Decode(&amp;localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get(&#34;Content-Type&#34;))
<span id="L645" class="ln">   645  </span>	if err != nil {
<span id="L646" class="ln">   646  </span>		newErr := datadog.GenericOpenAPIError{
<span id="L647" class="ln">   647  </span>			ErrorBody:    localVarBody,
<span id="L648" class="ln">   648  </span>			ErrorMessage: err.Error(),
<span id="L649" class="ln">   649  </span>		}
<span id="L650" class="ln">   650  </span>		return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L651" class="ln">   651  </span>	}
<span id="L652" class="ln">   652  </span>
<span id="L653" class="ln">   653  </span>	return localVarReturnValue, localVarHTTPResponse, nil
<span id="L654" class="ln">   654  </span>}
<span id="L655" class="ln">   655  </span>
<span id="L656" class="ln">   656  </span>type apiListAWSLogsIntegrationsRequest struct {
<span id="L657" class="ln">   657  </span>	ctx _context.Context
<span id="L658" class="ln">   658  </span>}
<span id="L659" class="ln">   659  </span>
<span id="L660" class="ln">   660  </span>func (a *AWSLogsIntegrationApi) buildListAWSLogsIntegrationsRequest(ctx _context.Context) (apiListAWSLogsIntegrationsRequest, error) {
<span id="L661" class="ln">   661  </span>	req := apiListAWSLogsIntegrationsRequest{
<span id="L662" class="ln">   662  </span>		ctx: ctx,
<span id="L663" class="ln">   663  </span>	}
<span id="L664" class="ln">   664  </span>	return req, nil
<span id="L665" class="ln">   665  </span>}
<span id="L666" class="ln">   666  </span>
<span id="L667" class="ln">   667  </span><span class="comment">// ListAWSLogsIntegrations List all AWS Logs integrations.</span>
<span id="L668" class="ln">   668  </span><span class="comment">// List all Datadog-AWS Logs integrations configured in your Datadog account.</span>
<span id="L669" class="ln">   669  </span>func (a *AWSLogsIntegrationApi) ListAWSLogsIntegrations(ctx _context.Context) ([]AWSLogsListResponse, *_nethttp.Response, error) {
<span id="L670" class="ln">   670  </span>	req, err := a.buildListAWSLogsIntegrationsRequest(ctx)
<span id="L671" class="ln">   671  </span>	if err != nil {
<span id="L672" class="ln">   672  </span>		var localVarReturnValue []AWSLogsListResponse
<span id="L673" class="ln">   673  </span>		return localVarReturnValue, nil, err
<span id="L674" class="ln">   674  </span>	}
<span id="L675" class="ln">   675  </span>
<span id="L676" class="ln">   676  </span>	return a.listAWSLogsIntegrationsExecute(req)
<span id="L677" class="ln">   677  </span>}
<span id="L678" class="ln">   678  </span>
<span id="L679" class="ln">   679  </span><span class="comment">// listAWSLogsIntegrationsExecute executes the request.</span>
<span id="L680" class="ln">   680  </span>func (a *AWSLogsIntegrationApi) listAWSLogsIntegrationsExecute(r apiListAWSLogsIntegrationsRequest) ([]AWSLogsListResponse, *_nethttp.Response, error) {
<span id="L681" class="ln">   681  </span>	var (
<span id="L682" class="ln">   682  </span>		localVarHTTPMethod  = _nethttp.MethodGet
<span id="L683" class="ln">   683  </span>		localVarPostBody    interface{}
<span id="L684" class="ln">   684  </span>		localVarReturnValue []AWSLogsListResponse
<span id="L685" class="ln">   685  </span>	)
<span id="L686" class="ln">   686  </span>
<span id="L687" class="ln">   687  </span>	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, &#34;v1.AWSLogsIntegrationApi.ListAWSLogsIntegrations&#34;)
<span id="L688" class="ln">   688  </span>	if err != nil {
<span id="L689" class="ln">   689  </span>		return localVarReturnValue, nil, datadog.GenericOpenAPIError{ErrorMessage: err.Error()}
<span id="L690" class="ln">   690  </span>	}
<span id="L691" class="ln">   691  </span>
<span id="L692" class="ln">   692  </span>	localVarPath := localBasePath + &#34;/api/v1/integration/aws/logs&#34;
<span id="L693" class="ln">   693  </span>
<span id="L694" class="ln">   694  </span>	localVarHeaderParams := make(map[string]string)
<span id="L695" class="ln">   695  </span>	localVarQueryParams := _neturl.Values{}
<span id="L696" class="ln">   696  </span>	localVarFormParams := _neturl.Values{}
<span id="L697" class="ln">   697  </span>	localVarHeaderParams[&#34;Accept&#34;] = &#34;application/json&#34;
<span id="L698" class="ln">   698  </span>
<span id="L699" class="ln">   699  </span>	if r.ctx != nil {
<span id="L700" class="ln">   700  </span>		<span class="comment">// API Key Authentication</span>
<span id="L701" class="ln">   701  </span>		if auth, ok := r.ctx.Value(datadog.ContextAPIKeys).(map[string]datadog.APIKey); ok {
<span id="L702" class="ln">   702  </span>			if apiKey, ok := auth[&#34;apiKeyAuth&#34;]; ok {
<span id="L703" class="ln">   703  </span>				var key string
<span id="L704" class="ln">   704  </span>				if apiKey.Prefix != &#34;&#34; {
<span id="L705" class="ln">   705  </span>					key = apiKey.Prefix + &#34; &#34; + apiKey.Key
<span id="L706" class="ln">   706  </span>				} else {
<span id="L707" class="ln">   707  </span>					key = apiKey.Key
<span id="L708" class="ln">   708  </span>				}
<span id="L709" class="ln">   709  </span>				localVarHeaderParams[&#34;DD-API-KEY&#34;] = key
<span id="L710" class="ln">   710  </span>			}
<span id="L711" class="ln">   711  </span>		}
<span id="L712" class="ln">   712  </span>	}
<span id="L713" class="ln">   713  </span>	if r.ctx != nil {
<span id="L714" class="ln">   714  </span>		<span class="comment">// API Key Authentication</span>
<span id="L715" class="ln">   715  </span>		if auth, ok := r.ctx.Value(datadog.ContextAPIKeys).(map[string]datadog.APIKey); ok {
<span id="L716" class="ln">   716  </span>			if apiKey, ok := auth[&#34;appKeyAuth&#34;]; ok {
<span id="L717" class="ln">   717  </span>				var key string
<span id="L718" class="ln">   718  </span>				if apiKey.Prefix != &#34;&#34; {
<span id="L719" class="ln">   719  </span>					key = apiKey.Prefix + &#34; &#34; + apiKey.Key
<span id="L720" class="ln">   720  </span>				} else {
<span id="L721" class="ln">   721  </span>					key = apiKey.Key
<span id="L722" class="ln">   722  </span>				}
<span id="L723" class="ln">   723  </span>				localVarHeaderParams[&#34;DD-APPLICATION-KEY&#34;] = key
<span id="L724" class="ln">   724  </span>			}
<span id="L725" class="ln">   725  </span>		}
<span id="L726" class="ln">   726  </span>	}
<span id="L727" class="ln">   727  </span>	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, nil)
<span id="L728" class="ln">   728  </span>	if err != nil {
<span id="L729" class="ln">   729  </span>		return localVarReturnValue, nil, err
<span id="L730" class="ln">   730  </span>	}
<span id="L731" class="ln">   731  </span>
<span id="L732" class="ln">   732  </span>	localVarHTTPResponse, err := a.Client.CallAPI(req)
<span id="L733" class="ln">   733  </span>	if err != nil || localVarHTTPResponse == nil {
<span id="L734" class="ln">   734  </span>		return localVarReturnValue, localVarHTTPResponse, err
<span id="L735" class="ln">   735  </span>	}
<span id="L736" class="ln">   736  </span>
<span id="L737" class="ln">   737  </span>	localVarBody, err := _io.ReadAll(localVarHTTPResponse.Body)
<span id="L738" class="ln">   738  </span>	localVarHTTPResponse.Body.Close()
<span id="L739" class="ln">   739  </span>	localVarHTTPResponse.Body = _io.NopCloser(bytes.NewBuffer(localVarBody))
<span id="L740" class="ln">   740  </span>	if err != nil {
<span id="L741" class="ln">   741  </span>		return localVarReturnValue, localVarHTTPResponse, err
<span id="L742" class="ln">   742  </span>	}
<span id="L743" class="ln">   743  </span>
<span id="L744" class="ln">   744  </span>	if localVarHTTPResponse.StatusCode &gt;= 300 {
<span id="L745" class="ln">   745  </span>		newErr := datadog.GenericOpenAPIError{
<span id="L746" class="ln">   746  </span>			ErrorBody:    localVarBody,
<span id="L747" class="ln">   747  </span>			ErrorMessage: localVarHTTPResponse.Status,
<span id="L748" class="ln">   748  </span>		}
<span id="L749" class="ln">   749  </span>		if localVarHTTPResponse.StatusCode == 400 || localVarHTTPResponse.StatusCode == 403 || localVarHTTPResponse.StatusCode == 429 {
<span id="L750" class="ln">   750  </span>			var v APIErrorResponse
<span id="L751" class="ln">   751  </span>			err = a.Client.Decode(&amp;v, localVarBody, localVarHTTPResponse.Header.Get(&#34;Content-Type&#34;))
<span id="L752" class="ln">   752  </span>			if err != nil {
<span id="L753" class="ln">   753  </span>				return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L754" class="ln">   754  </span>			}
<span id="L755" class="ln">   755  </span>			newErr.ErrorModel = v
<span id="L756" class="ln">   756  </span>		}
<span id="L757" class="ln">   757  </span>		return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L758" class="ln">   758  </span>	}
<span id="L759" class="ln">   759  </span>
<span id="L760" class="ln">   760  </span>	err = a.Client.Decode(&amp;localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get(&#34;Content-Type&#34;))
<span id="L761" class="ln">   761  </span>	if err != nil {
<span id="L762" class="ln">   762  </span>		newErr := datadog.GenericOpenAPIError{
<span id="L763" class="ln">   763  </span>			ErrorBody:    localVarBody,
<span id="L764" class="ln">   764  </span>			ErrorMessage: err.Error(),
<span id="L765" class="ln">   765  </span>		}
<span id="L766" class="ln">   766  </span>		return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L767" class="ln">   767  </span>	}
<span id="L768" class="ln">   768  </span>
<span id="L769" class="ln">   769  </span>	return localVarReturnValue, localVarHTTPResponse, nil
<span id="L770" class="ln">   770  </span>}
<span id="L771" class="ln">   771  </span>
<span id="L772" class="ln">   772  </span>type apiListAWSLogsServicesRequest struct {
<span id="L773" class="ln">   773  </span>	ctx _context.Context
<span id="L774" class="ln">   774  </span>}
<span id="L775" class="ln">   775  </span>
<span id="L776" class="ln">   776  </span>func (a *AWSLogsIntegrationApi) buildListAWSLogsServicesRequest(ctx _context.Context) (apiListAWSLogsServicesRequest, error) {
<span id="L777" class="ln">   777  </span>	req := apiListAWSLogsServicesRequest{
<span id="L778" class="ln">   778  </span>		ctx: ctx,
<span id="L779" class="ln">   779  </span>	}
<span id="L780" class="ln">   780  </span>	return req, nil
<span id="L781" class="ln">   781  </span>}
<span id="L782" class="ln">   782  </span>
<span id="L783" class="ln">   783  </span><span class="comment">// ListAWSLogsServices Get list of AWS log ready services.</span>
<span id="L784" class="ln">   784  </span><span class="comment">// Get the list of current AWS services that Datadog offers automatic log collection. Use returned service IDs with the services parameter for the Enable an AWS service log collection API endpoint.</span>
<span id="L785" class="ln">   785  </span>func (a *AWSLogsIntegrationApi) ListAWSLogsServices(ctx _context.Context) ([]AWSLogsListServicesResponse, *_nethttp.Response, error) {
<span id="L786" class="ln">   786  </span>	req, err := a.buildListAWSLogsServicesRequest(ctx)
<span id="L787" class="ln">   787  </span>	if err != nil {
<span id="L788" class="ln">   788  </span>		var localVarReturnValue []AWSLogsListServicesResponse
<span id="L789" class="ln">   789  </span>		return localVarReturnValue, nil, err
<span id="L790" class="ln">   790  </span>	}
<span id="L791" class="ln">   791  </span>
<span id="L792" class="ln">   792  </span>	return a.listAWSLogsServicesExecute(req)
<span id="L793" class="ln">   793  </span>}
<span id="L794" class="ln">   794  </span>
<span id="L795" class="ln">   795  </span><span class="comment">// listAWSLogsServicesExecute executes the request.</span>
<span id="L796" class="ln">   796  </span>func (a *AWSLogsIntegrationApi) listAWSLogsServicesExecute(r apiListAWSLogsServicesRequest) ([]AWSLogsListServicesResponse, *_nethttp.Response, error) {
<span id="L797" class="ln">   797  </span>	var (
<span id="L798" class="ln">   798  </span>		localVarHTTPMethod  = _nethttp.MethodGet
<span id="L799" class="ln">   799  </span>		localVarPostBody    interface{}
<span id="L800" class="ln">   800  </span>		localVarReturnValue []AWSLogsListServicesResponse
<span id="L801" class="ln">   801  </span>	)
<span id="L802" class="ln">   802  </span>
<span id="L803" class="ln">   803  </span>	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, &#34;v1.AWSLogsIntegrationApi.ListAWSLogsServices&#34;)
<span id="L804" class="ln">   804  </span>	if err != nil {
<span id="L805" class="ln">   805  </span>		return localVarReturnValue, nil, datadog.GenericOpenAPIError{ErrorMessage: err.Error()}
<span id="L806" class="ln">   806  </span>	}
<span id="L807" class="ln">   807  </span>
<span id="L808" class="ln">   808  </span>	localVarPath := localBasePath + &#34;/api/v1/integration/aws/logs/services&#34;
<span id="L809" class="ln">   809  </span>
<span id="L810" class="ln">   810  </span>	localVarHeaderParams := make(map[string]string)
<span id="L811" class="ln">   811  </span>	localVarQueryParams := _neturl.Values{}
<span id="L812" class="ln">   812  </span>	localVarFormParams := _neturl.Values{}
<span id="L813" class="ln">   813  </span>	localVarHeaderParams[&#34;Accept&#34;] = &#34;application/json&#34;
<span id="L814" class="ln">   814  </span>
<span id="L815" class="ln">   815  </span>	if r.ctx != nil {
<span id="L816" class="ln">   816  </span>		<span class="comment">// API Key Authentication</span>
<span id="L817" class="ln">   817  </span>		if auth, ok := r.ctx.Value(datadog.ContextAPIKeys).(map[string]datadog.APIKey); ok {
<span id="L818" class="ln">   818  </span>			if apiKey, ok := auth[&#34;apiKeyAuth&#34;]; ok {
<span id="L819" class="ln">   819  </span>				var key string
<span id="L820" class="ln">   820  </span>				if apiKey.Prefix != &#34;&#34; {
<span id="L821" class="ln">   821  </span>					key = apiKey.Prefix + &#34; &#34; + apiKey.Key
<span id="L822" class="ln">   822  </span>				} else {
<span id="L823" class="ln">   823  </span>					key = apiKey.Key
<span id="L824" class="ln">   824  </span>				}
<span id="L825" class="ln">   825  </span>				localVarHeaderParams[&#34;DD-API-KEY&#34;] = key
<span id="L826" class="ln">   826  </span>			}
<span id="L827" class="ln">   827  </span>		}
<span id="L828" class="ln">   828  </span>	}
<span id="L829" class="ln">   829  </span>	if r.ctx != nil {
<span id="L830" class="ln">   830  </span>		<span class="comment">// API Key Authentication</span>
<span id="L831" class="ln">   831  </span>		if auth, ok := r.ctx.Value(datadog.ContextAPIKeys).(map[string]datadog.APIKey); ok {
<span id="L832" class="ln">   832  </span>			if apiKey, ok := auth[&#34;appKeyAuth&#34;]; ok {
<span id="L833" class="ln">   833  </span>				var key string
<span id="L834" class="ln">   834  </span>				if apiKey.Prefix != &#34;&#34; {
<span id="L835" class="ln">   835  </span>					key = apiKey.Prefix + &#34; &#34; + apiKey.Key
<span id="L836" class="ln">   836  </span>				} else {
<span id="L837" class="ln">   837  </span>					key = apiKey.Key
<span id="L838" class="ln">   838  </span>				}
<span id="L839" class="ln">   839  </span>				localVarHeaderParams[&#34;DD-APPLICATION-KEY&#34;] = key
<span id="L840" class="ln">   840  </span>			}
<span id="L841" class="ln">   841  </span>		}
<span id="L842" class="ln">   842  </span>	}
<span id="L843" class="ln">   843  </span>	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, nil)
<span id="L844" class="ln">   844  </span>	if err != nil {
<span id="L845" class="ln">   845  </span>		return localVarReturnValue, nil, err
<span id="L846" class="ln">   846  </span>	}
<span id="L847" class="ln">   847  </span>
<span id="L848" class="ln">   848  </span>	localVarHTTPResponse, err := a.Client.CallAPI(req)
<span id="L849" class="ln">   849  </span>	if err != nil || localVarHTTPResponse == nil {
<span id="L850" class="ln">   850  </span>		return localVarReturnValue, localVarHTTPResponse, err
<span id="L851" class="ln">   851  </span>	}
<span id="L852" class="ln">   852  </span>
<span id="L853" class="ln">   853  </span>	localVarBody, err := _io.ReadAll(localVarHTTPResponse.Body)
<span id="L854" class="ln">   854  </span>	localVarHTTPResponse.Body.Close()
<span id="L855" class="ln">   855  </span>	localVarHTTPResponse.Body = _io.NopCloser(bytes.NewBuffer(localVarBody))
<span id="L856" class="ln">   856  </span>	if err != nil {
<span id="L857" class="ln">   857  </span>		return localVarReturnValue, localVarHTTPResponse, err
<span id="L858" class="ln">   858  </span>	}
<span id="L859" class="ln">   859  </span>
<span id="L860" class="ln">   860  </span>	if localVarHTTPResponse.StatusCode &gt;= 300 {
<span id="L861" class="ln">   861  </span>		newErr := datadog.GenericOpenAPIError{
<span id="L862" class="ln">   862  </span>			ErrorBody:    localVarBody,
<span id="L863" class="ln">   863  </span>			ErrorMessage: localVarHTTPResponse.Status,
<span id="L864" class="ln">   864  </span>		}
<span id="L865" class="ln">   865  </span>		if localVarHTTPResponse.StatusCode == 403 || localVarHTTPResponse.StatusCode == 429 {
<span id="L866" class="ln">   866  </span>			var v APIErrorResponse
<span id="L867" class="ln">   867  </span>			err = a.Client.Decode(&amp;v, localVarBody, localVarHTTPResponse.Header.Get(&#34;Content-Type&#34;))
<span id="L868" class="ln">   868  </span>			if err != nil {
<span id="L869" class="ln">   869  </span>				return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L870" class="ln">   870  </span>			}
<span id="L871" class="ln">   871  </span>			newErr.ErrorModel = v
<span id="L872" class="ln">   872  </span>		}
<span id="L873" class="ln">   873  </span>		return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L874" class="ln">   874  </span>	}
<span id="L875" class="ln">   875  </span>
<span id="L876" class="ln">   876  </span>	err = a.Client.Decode(&amp;localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get(&#34;Content-Type&#34;))
<span id="L877" class="ln">   877  </span>	if err != nil {
<span id="L878" class="ln">   878  </span>		newErr := datadog.GenericOpenAPIError{
<span id="L879" class="ln">   879  </span>			ErrorBody:    localVarBody,
<span id="L880" class="ln">   880  </span>			ErrorMessage: err.Error(),
<span id="L881" class="ln">   881  </span>		}
<span id="L882" class="ln">   882  </span>		return localVarReturnValue, localVarHTTPResponse, newErr
<span id="L883" class="ln">   883  </span>	}
<span id="L884" class="ln">   884  </span>
<span id="L885" class="ln">   885  </span>	return localVarReturnValue, localVarHTTPResponse, nil
<span id="L886" class="ln">   886  </span>}
<span id="L887" class="ln">   887  </span>
<span id="L888" class="ln">   888  </span><span class="comment">// NewAWSLogsIntegrationApi Returns NewAWSLogsIntegrationApi.</span>
<span id="L889" class="ln">   889  </span>func NewAWSLogsIntegrationApi(client *datadog.APIClient) *AWSLogsIntegrationApi {
<span id="L890" class="ln">   890  </span>	return &amp;AWSLogsIntegrationApi{
<span id="L891" class="ln">   891  </span>		Client: client,
<span id="L892" class="ln">   892  </span>	}
<span id="L893" class="ln">   893  </span>}
<span id="L894" class="ln">   894  </span>
</pre><p></p>

<div id="footer">
Build version go1.19.4.<br/>
</div>

</div><!-- .container -->
</div><!-- #page -->


</body></html>